(use tree-manual.uscm)

(val list '())

(define path (n t)
    (begin
	 (if 
	  (not (tree? t)) 'error
	  (if (not (tree-search n t)) #f
	   (if (= n (tree-datum t)) 
        (begin
         (println list)
         (set list '())
        )
	    (if (< n (tree-datum t))
         (begin 
          (path n (tree-left t))
          (set list (cons 'left list))
         )
         (begin
          (path n (tree-right t))
          (set list (cons 'right list))
         ) 
        ) 
	   )
      )
     )
    )
)

(path 12 (tree-add 12 (tree-add 11 (tree-add 15 (tree-add 9 (tree-add 8 (tree-add 2 (tree-add 1 (tree-add 5 (tree-add 3 (tree-add 7 (tree-make-null))))))))))))
(path 2 (tree-add 12 (tree-add 11 (tree-add 15 (tree-add 9 (tree-add 8 (tree-add 2 (tree-add 1 (tree-add 5 (tree-add 3 (tree-add 7 (tree-make-null))))))))))))



(val exploded '())

(define explode-digits (n)

    (begin

        (set exploded '())

        (while (>= n 1)     ; running until the number isn't an integer

            (begin
                
                (set exploded (cons (mod n 10) exploded))   ; building a list using 'mod' to split the numbers

                (set n (/ n 10))

            )
        )

        (println exploded)

    )
)

(explode-digits 123456789)
(explode-digits 2468)



(val imploded 1)
(val j 0)
(val counter 1)

(define implode-digits (n)

    (begin

        (set imploded 1)
        (set j 0)
        (set counter 1)

        (while (not (null? (cdr n)))    ; goes through and concatenates atoms by doing iterative decimal math

            (begin

                (set imploded (* imploded 10))      ; imploded will have another '1' at the start of the number due to decimal math completed

                (set imploded (+ imploded (car n))) ; sum the numbers

                (set n (cdr n))                     ; iterate to the next element

                (set j (+ j 1))                     ; iterate a counter for later

            )
        )

        (set imploded (* imploded 10))              ; need to catch the missed digit due to the while conditional
        (set imploded (+ imploded (car n)))

        (while (> j -1)                             ; determining what needs to be cut off of 'imploded'

            (begin

                (set counter (* counter 10))
            
                (set j (- j 1))

            )
        )

        (set imploded (- imploded counter)) ; cutting of the initial '1' that 'imploded' was defined as

        (println imploded)

    )
)

(implode-digits '(1 2 3 4))
(implode-digits '(2 4 6 8))



(val sum 0)

(val bool 0)

(val check 0)

(define equal-length (l1 l2)        ; Helper function to check if the lengths are equal

    (begin 

        (set check 0)
        (set bool 0)        ; has a dummy bool value to use in the driver function

        (while (= check 0)  ; just checks each base case to find null cases and determine equivalence from that (basically using a cond)

            (begin

                (if (and (null? (cdr l1)) (null? (cdr l2)))

                    (begin

                        (set bool 1)
                        (set check 1)

                    )

                    (if (null? (cdr l1))

                        (set check 1)

                        (if (null? (cdr l2))

                            (set check 1)

                            (begin

                                (set l1 (cdr l1))
                                (set l2 (cdr l2))

                            )
                        )
                    )
                )
            )
        )

        (println bool)

    )
  )

(equal-length '(1 2 3 1) '(2 3 3 4))
(equal-length '(1 2 3) '(2 3 3 4))
(equal-length '(1 2 3 1) '(2 3 3))
(equal-length '(1 2) '(2 3))



(define dot-product (l1 l2)

    (begin
    
        (set sum 0)

        (if (= (equal-length l1 l2) 1)              ; checking to ensure the lists are equal in size

            (begin

                (while (not (null? (cdr l1)))       ; checking to make sure the list is at least 1 index out

                    (begin                          ; if so, calculate the terms multiplied and add to the sum

                        (set sum (+ sum (* (car l1) (car l2) )))    

                        (set l1 (cdr l1))

                        (set l2 (cdr l2))

                    )
                )

                (set sum (+ sum (* (car l1) (car l2) )))    ; need to account for the lost index due to ending the loop when the cdr is null

            )

            0

        )

        (println sum)

    )
)

(dot-product '(1 2 3) '(2 3 1))
(dot-product '(1 2 3) '(2 3 4))
(dot-product '(1 2 3) '(2 3))
(dot-product '(1 2 3) '(2 3 8 9))



(define count (key list)

    (begin

        (set sum 0)
    
        (while (not (null? (cdr list)))     ; ensuring the list isn't 1 index from the end

            (begin

                (if (pair? (car list))      ; checking if the element is a sublist

                    (set list (cdr list))   ; if so, just skip it

                    (begin
                    
                        (if (= (car list) key)  ; if not, check for the key and iterate if found
                        
                            (set sum (+ sum 1))

                            0

                        )

                        (set list (cdr list))
                    
                    )
                )
            )
        )

        (if (pair? (car list))      ; since the loop ends 1 index early, that needs to be recovered with 1 additional iteration

                    (set list (cdr list))

                    (begin
                    
                        (if (= (car list) key)
                        
                            (set sum (+ sum 1))

                            0

                        )

                        (set list (cdr list))
                    
                    )
                )

        (println sum)

    )
)


(count 'a '(a (a a a) a))
(count 'a '(a b a c a))
(count '1 '(1 2 3 4 1))
(count '() '(1 2 3))



(define postorder (t)
	(if (tree-null? t)
	'()
	(append
		( postorder (tree-left t) )
	(append		
		( postorder (tree-right t))
		(cons	(tree-datum t) '() )))
	))
(postorder (tree-add 7 (tree-add 5 (tree-add 3 (tree-add 1 (tree-add 2 (tree-add 4 (tree-make-null))))))))



(define inorder (t)
    (if (tree-null? t) 
    '()
    (append 
	(inorder (tree-left t))
		(cons (tree-datum t)
		(inorder (tree-right t))))))

(inorder (tree-add 7 (tree-add 5 (tree-add 6 (tree-add 3 (tree-add 1 (tree-add 2 (tree-add 4 (tree-make-null)))))))))



(define append-item (list item)     ; Helper function to build the list to get around an error I was getting (car applied to non-pair 3 in (car xs))

    (if (null? list)                ; checking if it's null

        (cons item '())             ; if so, cons'ing a null list on

        (cons (car list) (append-item (cdr list) item)) ; if not, cons'ing the car with a recursive call to itself to keep building in reverse
        
    )
)



(define mirror (list)

    (if (null? list)

        '()

        (if (pair? (car list))                                      ; checking for a sublist

            (append-item (mirror (cdr list)) (mirror (car list)))   ; if so, need to further split each part, in reverse order

            (append-item (mirror (cdr list)) (car list))            ; if not, the first element doesn't need to be split further
            
        )
    )
)

(mirror '(1 2 3)) 
(mirror '(1 (2 3) 4)) 



(define flatten (list)

    (if (null? list)

        '()                                                     ; returning a null if null

        (if (pair? (car list))                                  ; checking if it's a sublist

            (append (flatten (car list)) (flatten (cdr list)))  ; if so, recursively calling itself to further split the list

            (cons (car list) (flatten (cdr list)))              ; if not, constructing a new list of the atoms
            
        )
    )
)

(flatten '(((1) 2) (3 (4 5))))
(flatten '((((((((22)))))))))



(define countall (key list)

    (begin
    
        (set sum 0)

    )
)
